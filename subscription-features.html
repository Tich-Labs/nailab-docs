<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nailab - Subscription Features</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50" data-page-title="Subscription Features">
    <div class="min-h-screen">
        <div id="nailabHeader"></div>
        <script src="shared.js"></script>
        <script>window.NailabShared.renderHeader();</script>

        <!-- Main Content -->
        <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <!-- Overview Stats -->
            <div class="bg-white rounded-lg shadow-sm p-6 mb-8 animate-slide-in">
                <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
                    <div class="text-center">
                        <div class="flex justify-center mb-2">
                            <svg class="w-12 h-12 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </div>
                        <h3 id="statCompletePercent" class="text-2xl font-bold text-green-600">0%</h3>
                        <p class="text-sm text-gray-600">Complete</p>
                    </div>
                    <div class="text-center">
                        <div class="flex justify-center mb-2">
                            <svg class="w-12 h-12 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                        </div>
                        <h3 id="statInProgress" class="text-2xl font-bold text-yellow-600">0</h3>
                        <p class="text-sm text-gray-600">In Progress</p>
                    </div>
                    <div class="text-center">
                        <div class="flex justify-center mb-2">
                            <svg class="w-12 h-12 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                            </svg>
                        </div>
                        <h3 id="statMissing" class="text-2xl font-bold text-red-600">7</h3>
                        <p class="text-sm text-gray-600">Missing</p>
                    </div>
                    <div class="text-center">
                        <div class="flex justify-center mb-2">
                            <svg class="w-12 h-12 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
                            </svg>
                        </div>
                        <h3 id="statTotal" class="text-2xl font-bold text-blue-600">7</h3>
                        <p class="text-sm text-gray-600">Total Features</p>
                    </div>
                </div>
            </div>

            <!-- Legend -->
            <div class="bg-white rounded-lg shadow-sm p-6 mb-8">
                <h3 class="text-lg font-semibold mb-4">Status Legend</h3>
                <p class="text-sm text-gray-600 mb-4">Tip: drag cards between columns (including back). Double-click a card to edit its title/description.</p>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div class="flex items-center space-x-3">
                        <div class="w-4 h-4 bg-green-500 rounded-full"></div>
                        <div>
                            <p class="font-medium">Complete ‚úÖ</p>
                            <p class="text-sm text-gray-600">Feature is fully implemented and functional</p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-3">
                        <div class="w-4 h-4 bg-yellow-500 rounded-full"></div>
                        <div>
                            <p class="font-medium">Partial üü°</p>
                            <p class="text-sm text-gray-600">Feature exists but needs enhancements</p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-3">
                        <div class="w-4 h-4 bg-red-500 rounded-full"></div>
                        <div>
                            <p class="font-medium">Missing ‚ùå</p>
                            <p class="text-sm text-gray-600">Feature is not implemented</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Kanban Board -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Completed Column -->
                <div class="bg-green-50 rounded-lg border border-green-200">
                    <div class="p-4 border-b border-green-200">
                        <h3 class="font-semibold text-green-800 flex items-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            Completed (<span id="countComplete">0</span>)
                        </h3>
                    </div>
                    <div class="p-4 space-y-3 kanban-column" data-column="complete"></div>
                </div>

                <!-- In Progress Column -->
                <div class="bg-yellow-50 rounded-lg border border-yellow-200">
                    <div class="p-4 border-b border-yellow-200">
                        <h3 class="font-semibold text-yellow-800 flex items-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            In Progress (<span id="countInProgress">0</span>)
                        </h3>
                    </div>
                    <div class="p-4 space-y-3 kanban-column" data-column="in_progress"></div>
                </div>

                <!-- Missing Column -->
                <div class="bg-red-50 rounded-lg border border-red-200">
                    <div class="p-4 border-b border-red-200">
                        <h3 class="font-semibold text-red-800 flex items-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                            </svg>
                            Missing (<span id="countMissing">7</span>)
                        </h3>
                    </div>
                    <div class="p-4 space-y-3 kanban-column" data-column="missing">
                        <div class="feature-card bg-white rounded-lg p-3 shadow-sm border border-gray-200" data-feature-id="integrate-secure-payment-gateway">
                            <h4 class="font-medium text-gray-900 mb-1">Integrate Secure Payment Gateway (Stripe + M-Pesa)</h4>
                            <p class="text-sm text-gray-600 mb-2">Integrate a secure payment gateway that supports both Card payments (via Stripe) and M-Pesa transactions. Stripe will be used for all subscriptions.</p>
                            <span class="status-badge bg-red-100 text-red-800">‚ùå Missing</span>
                        </div>

                        <div class="feature-card bg-white rounded-lg p-3 shadow-sm border border-gray-200" data-feature-id="implement-subscription-tiers-logic-backend">
                            <h4 class="font-medium text-gray-900 mb-1">Implement Subscription Tiers Logic (Backend)</h4>
                            <p class="text-sm text-gray-600 mb-2">Define and implement backend business logic for different subscription tiers and the features each tier unlocks.</p>
                            <span class="status-badge bg-red-100 text-red-800">‚ùå Missing</span>
                        </div>

                        <div class="feature-card bg-white rounded-lg p-3 shadow-sm border border-gray-200" data-feature-id="build-user-subscription-selection-payment-flow">
                            <h4 class="font-medium text-gray-900 mb-1">Build User Subscription Selection &amp; Payment Flow</h4>
                            <p class="text-sm text-gray-600 mb-2">Create the complete frontend flow for users to browse tiers, select a plan, enter payment details and complete subscription purchase.</p>
                            <span class="status-badge bg-red-100 text-red-800">‚ùå Missing</span>
                        </div>

                        <div class="feature-card bg-white rounded-lg p-3 shadow-sm border border-gray-200" data-feature-id="implement-transaction-confirmation-emails">
                            <h4 class="font-medium text-gray-900 mb-1">Implement Transaction Confirmation Emails</h4>
                            <p class="text-sm text-gray-600 mb-2">Automatically send confirmation email to user after successful subscription payment.</p>
                            <span class="status-badge bg-red-100 text-red-800">‚ùå Missing</span>
                        </div>

                        <div class="feature-card bg-white rounded-lg p-3 shadow-sm border border-gray-200" data-feature-id="implement-automatic-receipt-generation-delivery">
                            <h4 class="font-medium text-gray-900 mb-1">Implement Automatic Receipt Generation &amp; Delivery</h4>
                            <p class="text-sm text-gray-600 mb-2">Generate and provide users with proper receipts/invoices after successful payment.</p>
                            <span class="status-badge bg-red-100 text-red-800">‚ùå Missing</span>
                        </div>

                        <div class="feature-card bg-white rounded-lg p-3 shadow-sm border border-gray-200" data-feature-id="build-subscription-management-dashboard">
                            <h4 class="font-medium text-gray-900 mb-1">Build Subscription Management Dashboard</h4>
                            <p class="text-sm text-gray-600 mb-2">Allow users to view &amp; manage their subscription status, payment methods, renewals and cancellations.</p>
                            <span class="status-badge bg-red-100 text-red-800">‚ùå Missing</span>
                        </div>

                        <div class="feature-card bg-white rounded-lg p-3 shadow-sm border border-gray-200" data-feature-id="enforce-access-control-frontend-backend">
                            <h4 class="font-medium text-gray-900 mb-1">Enforce Access Control (Frontend + Backend)</h4>
                            <p class="text-sm text-gray-600 mb-2">Implement complete authorization checks to protect premium content and mentorship features based on active subscription tier.</p>
                            <span class="status-badge bg-red-100 text-red-800">‚ùå Missing</span>
                        </div>
                    </div>
                </div>
            </div>

        </main>
    </div>

    <script>
        // Set last updated date
        document.getElementById('lastUpdated').textContent = new Date().toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        });

        // Kanban drag/drop + persistence
        document.addEventListener('DOMContentLoaded', function() {
            const STORAGE_KEY = 'nailab_subscription_features_board_v2';
            const columns = Array.from(document.querySelectorAll('.kanban-column[data-column]'));
            const cards = Array.from(document.querySelectorAll('.feature-card'));
            let screenshotPaths = [];

            function ensureScreenshotDatalist() {
                let list = document.getElementById('screenshotOptions');
                if (list) return list;
                list = document.createElement('datalist');
                list.id = 'screenshotOptions';
                document.body.appendChild(list);
                return list;
            }

            function updateScreenshotDatalist() {
                const list = ensureScreenshotDatalist();
                list.innerHTML = '';
                screenshotPaths.forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p;
                    list.appendChild(opt);
                });
            }

            function normalize(str) {
                return (str || '').toLowerCase().replace(/[^a-z0-9\s-]/g, '').replace(/\s+/g, ' ').trim();
            }

            function chooseFirstExisting(candidates) {
                for (const p of candidates) {
                    if (screenshotPaths.includes(p)) return p;
                }
                return null;
            }

            function suggestScreenshotForTitle(title) {
                const t = normalize(title);
                if (!t) return null;

                // Specific, high-confidence mappings
                if (t.includes('password reset') || t.includes('forgot password')) {
                    return chooseFirstExisting(['screenshots/site/auth/auth_password_new.png']);
                }
                if (t.includes('email confirmation') || t.includes('account activation') || t.includes('confirmation')) {
                    return chooseFirstExisting(['screenshots/site/auth/auth_confirmation_new.png']);
                }
                if (t.includes('sign in') || t.includes('login')) {
                    return chooseFirstExisting(['screenshots/site/auth/auth_sign_in.png']);
                }
                if (t.includes('registration') || t.includes('sign up') || t.includes('signup')) {
                    return chooseFirstExisting(['screenshots/site/auth/auth_sign_up.png']);
                }
                if (t.includes('account settings')) {
                    return chooseFirstExisting(['screenshots/founder/account_settings.png']);
                }
                if (t.includes('progress') && (t.includes('tracking') || t.includes('tracker'))) {
                    return chooseFirstExisting(['screenshots/founder/progress_tracker.png']);
                }
                if (t.includes('support')) {
                    return chooseFirstExisting(['screenshots/founder/support_center.png']);
                }
                if (t.includes('messaging') || t.includes('messages')) {
                    return chooseFirstExisting(['screenshots/founder/messages.png']);
                }
                if (t.includes('dashboard')) {
                    return chooseFirstExisting(['screenshots/founder/dashboard.png']);
                }
                if (t.includes('startup profile') || t.includes('startup details') || t.includes('profile wizard')) {
                    return chooseFirstExisting(['screenshots/founder/Startup_profile.png']);
                }

                // Fallback: best-effort filename match
                const tokens = t.split(' ').filter(Boolean);
                let best = null;
                let bestScore = 0;
                for (const p of screenshotPaths) {
                    const n = normalize(p);
                    let score = 0;
                    for (const tok of tokens) {
                        if (tok.length < 4) continue;
                        if (n.includes(tok)) score += 1;
                    }
                    if (score > bestScore) {
                        bestScore = score;
                        best = p;
                    }
                }
                return bestScore >= 2 ? best : null;
            }

            function formatDateTime(iso) {
                if (!iso) return '‚Äî';
                const d = new Date(iso);
                if (Number.isNaN(d.getTime())) return '‚Äî';
                return d.toLocaleString(undefined, {
                    year: 'numeric',
                    month: 'short',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }

            function ensureMetaRow(card) {
                let meta = card.querySelector('[data-meta-row]');
                if (meta) return meta;
                meta = document.createElement('div');
                meta.dataset.metaRow = '1';
                meta.className = 'mt-2 flex flex-wrap items-center gap-2 text-xs text-slate-500';
                meta.innerHTML = '<span data-created>Created: ‚Äî</span><span class="text-slate-300">‚Ä¢</span><span data-moved>Moved: ‚Äî</span>';
                card.appendChild(meta);
                return meta;
            }

                        function ensureScreenshotSection(card) {
                                let section = card.querySelector('[data-screenshot-section]');
                                if (section) return section;

                                section = document.createElement('div');
                                section.dataset.screenshotSection = '1';
                                section.className = 'mt-2';
                                section.innerHTML = `
                                        <div class="text-xs font-semibold text-slate-700">Screenshot</div>
                                        <a data-ss-link class="text-sm text-blue-600 underline" target="_blank" rel="noopener noreferrer" href="#">Not linked</a>
                                        <img data-ss-img class="mt-2 w-full max-h-40 object-cover rounded-lg border border-slate-200 cursor-pointer" alt="Screenshot preview" hidden />
                                        <div data-ss-picker class="mt-2 flex gap-2 items-center" hidden>
                                            <input data-ss-input class="flex-1 rounded-lg border border-slate-300 bg-white px-2 py-1 text-sm" list="screenshotOptions" placeholder="Choose screenshot path (e.g. screenshots/site/auth/auth_password_new.png)" />
                                            <button type="button" data-ss-set class="rounded-lg border border-slate-300 bg-white px-3 py-1 text-sm hover:bg-slate-50">Set</button>
                                        </div>
                                `;

                // Place it before details toggle if present (keeps it near status)
                const toggle = card.querySelector('[data-details-toggle]');
                if (toggle) {
                    card.insertBefore(section, toggle);
                } else {
                    const meta = card.querySelector('[data-meta-row]');
                    if (meta) card.insertBefore(section, meta);
                    else card.appendChild(section);
                }

                return section;
            }

            function renderCardScreenshot(card) {
                const section = ensureScreenshotSection(card);
                const link = section.querySelector('[data-ss-link]');
                const img = section.querySelector('[data-ss-img]');
                const picker = section.querySelector('[data-ss-picker]');
                const input = section.querySelector('[data-ss-input]');

                const path = card.dataset.screenshotPath || '';
                if (input) input.value = path;

                if (path) {
                    link.textContent = 'Open screenshot';
                    link.href = path;
                    img.src = path;
                    img.hidden = false;
                    img.onclick = () => window.open(path, '_blank', 'noopener');
                } else {
                    link.textContent = 'Not linked';
                    link.href = '#';
                    img.hidden = true;
                    img.src = '';
                }

                // picker visible only while editing
                if (picker) picker.hidden = !card.classList.contains('editing');
            }

            function applyChecklistItem(li, item) {
                const checkbox = li.querySelector('input[type="checkbox"]');
                const label = li.querySelector('[data-check-label]');
                const text = (item && item.text ? String(item.text) : '').trim();
                const done = !!(item && item.done);

                if (label) label.textContent = text;
                if (checkbox) checkbox.checked = done;

                if (label) {
                    label.classList.toggle('line-through', done);
                    label.classList.toggle('text-slate-400', done);
                    label.classList.toggle('text-slate-600', !done);
                }
            }

            function ensureDetailsSection(card) {
                let title = card.querySelector('[data-details-title]');
                let list = card.querySelector('[data-details-list]');
                let wrap = card.querySelector('[data-details-wrap]');
                let toggle = card.querySelector('[data-details-toggle]');
                if (title && list && wrap && toggle) return { title, list, wrap, toggle };

                // Wrap holds title + list so we can hide/show together
                wrap = document.createElement('div');
                wrap.dataset.detailsWrap = '1';
                wrap.className = 'mt-1';

                title = document.createElement('div');
                title.dataset.detailsTitle = '1';
                title.className = 'mt-2 text-xs font-semibold text-slate-700';
                title.textContent = 'Additional details';

                list = document.createElement('ul');
                list.dataset.detailsList = '1';
                list.className = 'mt-1 space-y-1';

                toggle = document.createElement('button');
                toggle.type = 'button';
                toggle.dataset.detailsToggle = '1';
                toggle.className = 'mt-2 text-xs font-semibold text-slate-700 underline hover:text-slate-900';
                toggle.textContent = 'Hide details';

                // Create a stable id for aria-controls
                const controlsId = `details-${card.dataset.featureId || Math.random().toString(36).slice(2)}`;
                wrap.id = controlsId;
                toggle.setAttribute('aria-controls', controlsId);
                toggle.setAttribute('aria-expanded', 'true');

                wrap.appendChild(title);
                wrap.appendChild(list);

                // Insert details before meta row if meta exists; otherwise append.
                const meta = card.querySelector('[data-meta-row]');
                if (meta) {
                    card.insertBefore(wrap, meta);
                    card.insertBefore(toggle, wrap);
                } else {
                    card.appendChild(toggle);
                    card.appendChild(wrap);
                }

                return { title, list, wrap, toggle };
            }

            function getDetails(card) {
                const list = card.querySelector('[data-details-list]');
                if (!list) return [];
                return Array.from(list.querySelectorAll('li')).map(li => {
                    const cb = li.querySelector('input[type="checkbox"]');
                    const label = li.querySelector('[data-check-label]');
                    return {
                        text: (label?.textContent || '').trim(),
                        done: !!cb?.checked
                    };
                }).filter(it => it.text);
            }

            function setDetails(card, details) {
                const { list } = ensureDetailsSection(card);
                list.innerHTML = '';

                const values = Array.isArray(details) ? details : [];
                const normalized = values
                    .map(v => {
                        if (!v) return null;
                        if (typeof v === 'string') return { text: v, done: false };
                        if (typeof v === 'object') return { text: String(v.text || '').trim(), done: !!v.done };
                        return null;
                    })
                    .filter(v => v && v.text);

                normalized.forEach((item) => {
                    const li = document.createElement('li');
                    li.className = 'flex items-start gap-2';
                    li.innerHTML =
                        '<input type="checkbox" class="mt-1 h-4 w-4 rounded border-slate-300 text-emerald-600 focus:ring-emerald-200" />' +
                        '<span data-check-label class="text-sm text-slate-600"></span>';

                    const cb = li.querySelector('input[type="checkbox"]');
                    if (cb) {
                        cb.addEventListener('change', () => {
                            applyChecklistItem(li, { text: item.text, done: cb.checked });
                            saveBoardState();
                        });
                    }

                    applyChecklistItem(li, item);
                    list.appendChild(li);
                });
            }

            function applyDetailsVisibility(card, open) {
                const { wrap, toggle } = ensureDetailsSection(card);
                const isOpen = open !== false;
                card.dataset.detailsOpen = isOpen ? 'true' : 'false';
                wrap.hidden = !isOpen;
                toggle.textContent = isOpen ? 'Hide details' : 'Show details';
                toggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
            }

            function renderCardTimestamps(card) {
                const meta = ensureMetaRow(card);
                const createdEl = meta.querySelector('[data-created]');
                const movedEl = meta.querySelector('[data-moved]');
                if (createdEl) createdEl.textContent = `Created: ${formatDateTime(card.dataset.createdAt)}`;
                if (movedEl) movedEl.textContent = `Moved: ${formatDateTime(card.dataset.movedAt)}`;
            }

            function safeText(str) {
                return (str || '').trim().toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9\-]/g, '');
            }

            function ensureCardIds() {
                const seen = new Set();
                cards.forEach((card, idx) => {
                    if (card.dataset.featureId) return;
                    const title = card.querySelector('h4')?.textContent || `feature-${idx}`;
                    let base = safeText(title) || `feature-${idx}`;
                    let candidate = base;
                    let n = 2;
                    while (seen.has(candidate)) {
                        candidate = `${base}-${n}`;
                        n += 1;
                    }
                    seen.add(candidate);
                    card.dataset.featureId = candidate;
                });
            }

            function setBadgeForColumn(card, columnKey) {
                const badge = card.querySelector('.status-badge');
                if (!badge) return;
                badge.classList.remove(
                    'bg-green-100', 'text-green-800',
                    'bg-yellow-100', 'text-yellow-800',
                    'bg-red-100', 'text-red-800'
                );

                if (columnKey === 'complete') {
                    badge.textContent = '‚úÖ Complete';
                    badge.classList.add('bg-green-100', 'text-green-800');
                } else if (columnKey === 'in_progress') {
                    badge.textContent = 'üü° Partial';
                    badge.classList.add('bg-yellow-100', 'text-yellow-800');
                } else {
                    badge.textContent = '‚ùå Missing';
                    badge.classList.add('bg-red-100', 'text-red-800');
                }
            }

            function updateCounts() {
                const completeCount = document.querySelectorAll('.kanban-column[data-column="complete"] .feature-card').length;
                const inProgressCount = document.querySelectorAll('.kanban-column[data-column="in_progress"] .feature-card').length;
                const missingCount = document.querySelectorAll('.kanban-column[data-column="missing"] .feature-card').length;
                const total = completeCount + inProgressCount + missingCount;

                const pct = total === 0 ? 0 : Math.round((completeCount / total) * 100);

                const elCountComplete = document.getElementById('countComplete');
                const elCountInProgress = document.getElementById('countInProgress');
                const elCountMissing = document.getElementById('countMissing');
                const elStatCompletePercent = document.getElementById('statCompletePercent');
                const elStatInProgress = document.getElementById('statInProgress');
                const elStatMissing = document.getElementById('statMissing');
                const elStatTotal = document.getElementById('statTotal');

                if (elCountComplete) elCountComplete.textContent = String(completeCount);
                if (elCountInProgress) elCountInProgress.textContent = String(inProgressCount);
                if (elCountMissing) elCountMissing.textContent = String(missingCount);

                if (elStatCompletePercent) elStatCompletePercent.textContent = `${pct}%`;
                if (elStatInProgress) elStatInProgress.textContent = String(inProgressCount);
                if (elStatMissing) elStatMissing.textContent = String(missingCount);
                if (elStatTotal) elStatTotal.textContent = String(total);
            }

            function saveBoardState() {
                const state = {};
                columns.forEach(col => {
                    const colKey = col.dataset.column;
                    Array.from(col.querySelectorAll('.feature-card')).forEach(card => {
                        const title = card.querySelector('h4')?.textContent?.trim() || '';
                        const desc = card.querySelector('p')?.textContent?.trim() || '';
                        const details = getDetails(card);
                        state[card.dataset.featureId] = {
                            column: colKey,
                            title,
                            desc,
                            details,
                            screenshotPath: card.dataset.screenshotPath || null,
                            detailsOpen: card.dataset.detailsOpen === 'false' ? false : true,
                            createdAt: card.dataset.createdAt || null,
                            movedAt: card.dataset.movedAt || null
                        };
                    });
                });
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
                } catch (_) {
                    // ignore storage errors (private mode, quota, etc.)
                }
            }

            function restoreBoardState() {
                let state = null;
                try {
                    state = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null');
                } catch (_) {
                    state = null;
                }
                if (!state || typeof state !== 'object') return;

                const cardById = new Map(cards.map(c => [c.dataset.featureId, c]));
                const columnByKey = new Map(columns.map(c => [c.dataset.column, c]));

                Object.entries(state).forEach(([id, value]) => {
                    const card = cardById.get(id);
                    if (!card) return;

                    // Backward compatibility: older format stored {id: "column"}
                    const colKey = typeof value === 'string' ? value : value?.column;
                    const col = columnByKey.get(colKey);
                    if (col) {
                        col.appendChild(card);
                        setBadgeForColumn(card, colKey);
                    }

                    if (value && typeof value === 'object') {
                        const titleEl = card.querySelector('h4');
                        const descEl = card.querySelector('p');
                        if (titleEl && typeof value.title === 'string') titleEl.textContent = value.title;
                        if (descEl && typeof value.desc === 'string') descEl.textContent = value.desc;

                        if (Array.isArray(value.details)) setDetails(card, value.details);
                        if (typeof value.detailsOpen === 'boolean') applyDetailsVisibility(card, value.detailsOpen);

                        if (typeof value.screenshotPath === 'string' && value.screenshotPath) {
                            card.dataset.screenshotPath = value.screenshotPath;
                        }

                        if (typeof value.createdAt === 'string' && value.createdAt) card.dataset.createdAt = value.createdAt;
                        if (typeof value.movedAt === 'string' && value.movedAt) card.dataset.movedAt = value.movedAt;
                    }
                });
            }

            function bootstrapMissingState() {
                // Ensure every card has a createdAt and meta row even before any drag/edit.
                const nowIso = new Date().toISOString();
                let state = null;
                try {
                    state = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null');
                } catch (_) {
                    state = null;
                }
                if (!state || typeof state !== 'object') state = {};

                let changed = false;
                cards.forEach(card => {
                    ensureMetaRow(card);
                    const stored = state?.[card.dataset.featureId];
                    ensureDetailsSection(card);
                    ensureScreenshotSection(card);
                    if (!card.dataset.createdAt) {
                        // Prefer stored value if present; otherwise initialize.
                        if (stored && typeof stored === 'object' && typeof stored.createdAt === 'string' && stored.createdAt) {
                            card.dataset.createdAt = stored.createdAt;
                        } else {
                            card.dataset.createdAt = nowIso;
                            changed = true;
                        }
                    }
                    if (!card.dataset.movedAt) {
                        if (stored && typeof stored === 'object' && typeof stored.movedAt === 'string' && stored.movedAt) {
                            card.dataset.movedAt = stored.movedAt;
                        }
                    }

                    // Default details visibility: open unless stored otherwise
                    if (stored && typeof stored === 'object' && typeof stored.detailsOpen === 'boolean') {
                        applyDetailsVisibility(card, stored.detailsOpen);
                    } else {
                        applyDetailsVisibility(card, true);
                    }

                    renderCardTimestamps(card);
                    renderCardScreenshot(card);
                });

                if (changed) saveBoardState();
            }

            ensureCardIds();

            // Drag + drop
            cards.forEach(card => {
                card.draggable = true;

                // Tailwind-only interactivity (no external CSS)
                card.classList.add('transition', 'duration-200', 'transform', 'hover:-translate-y-0.5', 'hover:shadow-xl', 'cursor-grab', 'select-none');

                // Make title/desc editable on demand
                const titleEl = card.querySelector('h4');
                const descEl = card.querySelector('p');
                if (titleEl) titleEl.classList.add('editable');
                if (descEl) descEl.classList.add('editable');
                const detailsSection = ensureDetailsSection(card);

                const screenshotSection = ensureScreenshotSection(card);
                const shotInput = screenshotSection.querySelector('[data-ss-input]');
                const shotSet = screenshotSection.querySelector('[data-ss-set]');

                if (shotSet && shotInput) {
                    shotSet.addEventListener('click', () => {
                        const val = (shotInput.value || '').trim();
                        card.dataset.screenshotPath = val;
                        renderCardScreenshot(card);
                        saveBoardState();
                    });
                }

                // Toggle details
                detailsSection.toggle.addEventListener('click', () => {
                    const open = card.dataset.detailsOpen === 'false';
                    applyDetailsVisibility(card, open);
                    saveBoardState();
                });

                function enableEditing() {
                    card.classList.add('editing');
                    card.classList.add('ring-2', 'ring-blue-300', 'ring-offset-2');
                    card.classList.remove('cursor-grab');
                    card.draggable = false;
                    // Always expand while editing so checklist is accessible
                    applyDetailsVisibility(card, true);
                    if (titleEl) {
                        titleEl.contentEditable = 'true';
                        titleEl.setAttribute('role', 'textbox');
                    }
                    if (descEl) {
                        descEl.contentEditable = 'true';
                        descEl.setAttribute('role', 'textbox');
                    }
                    // Checklist is interactive via checkboxes; no text editing here.

                    // Show screenshot picker while editing
                    renderCardScreenshot(card);
                    // focus title first
                    if (titleEl) {
                        const range = document.createRange();
                        range.selectNodeContents(titleEl);
                        const sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);
                        titleEl.focus();
                    }
                }

                function disableEditing(save) {
                    card.classList.remove('editing');
                    card.classList.remove('ring-2', 'ring-blue-300', 'ring-offset-2');
                    card.classList.add('cursor-grab');
                    if (titleEl) titleEl.contentEditable = 'false';
                    if (descEl) descEl.contentEditable = 'false';
                    // Checklist is interactive via checkboxes.
                    card.draggable = true;
                    if (save) {
                        saveBoardState();
                    }

                    // Hide screenshot picker
                    renderCardScreenshot(card);
                }

                // Double-click anywhere on the card to edit
                card.addEventListener('dblclick', (e) => {
                    // Avoid triggering edit while dragging
                    if (card.classList.contains('dragging')) return;
                    enableEditing();
                    e.preventDefault();
                });

                // Save on blur (when leaving the card)
                card.addEventListener('focusout', () => {
                    if (!card.classList.contains('editing')) return;
                    // give focus a tick to move between title/desc without exiting edit mode
                    window.setTimeout(() => {
                        const active = document.activeElement;
                        if (card.contains(active)) return;
                        disableEditing(true);
                        renderCardTimestamps(card);
                    }, 0);
                });

                // ESC cancels editing (reverts by reloading from storage snapshot)
                card.addEventListener('keydown', (e) => {
                    if (!card.classList.contains('editing')) return;
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        // restore from saved state
                        restoreBoardState();
                        updateCounts();
                        disableEditing(false);
                    }
                    // prevent Enter from creating new lines in the title
                    if (e.key === 'Enter' && document.activeElement === titleEl) {
                        e.preventDefault();
                        if (descEl) descEl.focus();
                    }
                });

                card.addEventListener('dragstart', (e) => {
                    if (card.classList.contains('editing')) {
                        e.preventDefault();
                        return;
                    }
                    card.classList.add('dragging');
                    card.classList.add('opacity-50', 'cursor-grabbing');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', card.dataset.featureId);
                });

                card.addEventListener('dragend', () => {
                    card.classList.remove('dragging');
                    card.classList.remove('opacity-50', 'cursor-grabbing');
                    columns.forEach(c => {
                        c.classList.remove('drop-target', 'outline', 'outline-2', 'outline-dashed', 'outline-slate-400', 'outline-offset-4');
                    });
                });
            });

            columns.forEach(col => {
                col.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    col.classList.add('drop-target');
                    col.classList.add('outline', 'outline-2', 'outline-dashed', 'outline-slate-400', 'outline-offset-4');
                });

                col.addEventListener('dragleave', () => {
                    col.classList.remove('drop-target');
                    col.classList.remove('outline', 'outline-2', 'outline-dashed', 'outline-slate-400', 'outline-offset-4');
                });

                col.addEventListener('drop', (e) => {
                    e.preventDefault();
                    col.classList.remove('drop-target');
                    col.classList.remove('outline', 'outline-2', 'outline-dashed', 'outline-slate-400', 'outline-offset-4');
                    const id = e.dataTransfer.getData('text/plain');
                    const dragged = document.querySelector(`.feature-card[data-feature-id="${CSS.escape(id)}"]`);
                    if (!dragged) return;

                    col.appendChild(dragged);
                    setBadgeForColumn(dragged, col.dataset.column);
                    dragged.dataset.movedAt = new Date().toISOString();
                    renderCardTimestamps(dragged);
                    updateCounts();
                    saveBoardState();
                });
            });

            (function seedSubscriptionChecklistIfMissing() {
                let existingState = null;
                try {
                    const raw = localStorage.getItem(STORAGE_KEY);
                    if (raw) existingState = JSON.parse(raw);
                } catch (_) {
                    existingState = null;
                }
                if (!existingState || typeof existingState !== 'object') existingState = {};

                const seed = {
                    'integrate-secure-payment-gateway': [
                        { text: 'Research & select M-Pesa integration provider/partner (e.g. Daraja API, third-party like Pesapal, IntaSend, etc.)', done: false },
                        { text: 'Set up Stripe account + connect to backend', done: false },
                        { text: 'Implement Stripe Payment Intents / Checkout for cards', done: false },
                        { text: 'Implement M-Pesa STK Push + Callback handler', done: false },
                        { text: 'Create unified payment initiation service layer', done: false },
                        { text: 'Add comprehensive error handling & logging', done: false }
                    ],
                    'implement-subscription-tiers-logic-backend': [
                        { text: 'Define subscription tiers in database (name, price, duration, features list)', done: false },
                        { text: 'Create tier-feature mapping/enum', done: false },
                        { text: 'Implement logic to check if user has access to a specific feature based on active tier', done: false },
                        { text: 'Add tier upgrade/downgrade rules', done: false },
                        { text: 'Handle prorated billing cases (if required)', done: false }
                    ],
                    'build-user-subscription-selection-payment-flow': [
                        { text: 'Design & implement subscription tiers comparison page', done: false },
                        { text: 'Create tier selection screen', done: false },
                        { text: 'Build payment method selection (Card / M-Pesa)', done: false },
                        { text: 'Integrate Stripe Elements / Checkout UI', done: false },
                        { text: 'Implement M-Pesa phone number input + STK push trigger', done: false },
                        { text: 'Show loading states & transaction status', done: false },
                        { text: 'Handle success/failure redirects & messages', done: false }
                    ],
                    'implement-transaction-confirmation-emails': [
                        { text: 'Set up email service provider (e.g. Resend, SendGrid, AWS SES)', done: false },
                        { text: 'Create subscription confirmation email template', done: false },
                        { text: 'Trigger email after successful webhook/stripe event', done: false },
                        { text: 'Include subscription details, next billing date, amount', done: false },
                        { text: 'Handle email delivery failures & logging', done: false }
                    ],
                    'implement-automatic-receipt-generation-delivery': [
                        { text: 'Create receipt PDF generation logic (or HTML ‚Üí PDF)', done: false },
                        { text: 'Design clean receipt template (branding, details, amount, date, payment method)', done: false },
                        { text: 'Attach receipt PDF to confirmation email', done: false },
                        { text: 'Allow users to download receipt from account dashboard', done: false },
                        { text: 'Store receipt reference/link in database', done: false }
                    ],
                    'build-subscription-management-dashboard': [
                        { text: 'Create "My Subscription" page in user dashboard', done: false },
                        { text: 'Show current plan, status, next billing date, payment method', done: false },
                        { text: 'Allow update payment method (Stripe)', done: false },
                        { text: 'Implement cancellation flow with confirmation', done: false },
                        { text: 'Show subscription history / previous payments', done: false },
                        { text: 'Handle grace period & cancellation feedback (if required)', done: false }
                    ],
                    'enforce-access-control-frontend-backend': [
                        { text: 'Backend: Create middleware/guard that checks user subscription status & tier', done: false },
                        { text: 'Backend: Add feature flag checks in resolvers/controllers', done: false },
                        { text: 'Frontend: Implement route guards & component-level checks', done: false },
                        { text: 'Show upgrade teaser/locked states for non-subscribed users', done: false },
                        { text: 'Handle expired/cancelled subscriptions gracefully', done: false },
                        { text: 'Add cache invalidation strategy when subscription changes', done: false }
                    ]
                };

                let changed = false;
                cards.forEach((card) => {
                    const id = card.dataset.featureId;
                    const details = seed[id];
                    if (!details) return;

                    const stored = existingState?.[id];
                    const hasDetails = stored && typeof stored === 'object' && Array.isArray(stored.details) && stored.details.length > 0;
                    if (hasDetails) return;

                    setDetails(card, details);
                    changed = true;
                });

                if (changed) saveBoardState();
            })();

            restoreBoardState();
            bootstrapMissingState();
            updateCounts();

            // Load screenshot options (used for linking cards to screenshots)
            fetch('screenshots_index.json')
                .then(r => r.json())
                .then(list => {
                    if (Array.isArray(list)) screenshotPaths = list;
                    updateScreenshotDatalist();

                    // Auto-suggest screenshot for cards that aren't linked yet
                    cards.forEach(card => {
                        if (card.dataset.screenshotPath) return;
                        const title = card.querySelector('h4')?.textContent || '';
                        const suggestion = suggestScreenshotForTitle(title);
                        if (!suggestion) return;
                        card.dataset.screenshotPath = suggestion;
                        renderCardScreenshot(card);
                    });
                    saveBoardState();
                })
                .catch(() => {
                    // ignore; screenshot linking still works if manually typed
                });

        });
    </script>
</body>
</html>